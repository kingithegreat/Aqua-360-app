{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n      t && (r = t);\n      var _n = 0,\n        F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          return _n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[_n++]\n          };\n        },\n        e: function e(r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = !0,\n    u = !1;\n  return {\n    s: function s() {\n      t = t.call(r);\n    },\n    n: function n() {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function e(r) {\n      u = !0, o = r;\n    },\n    f: function f() {\n      try {\n        a || null == t[\"return\"] || t[\"return\"]();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar VELOCITY_FACTOR = 0.2;\nvar MAX_POINTERS = 20;\nvar PointerTracker = function () {\n  function PointerTracker() {\n    _classCallCheck(this, PointerTracker);\n    _defineProperty(this, \"trackedPointers\", new Map());\n    _defineProperty(this, \"touchEventsIds\", new Map());\n    _defineProperty(this, \"lastMovedPointerId\", void 0);\n    _defineProperty(this, \"cachedAverages\", {\n      x: 0,\n      y: 0\n    });\n    this.lastMovedPointerId = NaN;\n    for (var i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n  return _createClass(PointerTracker, [{\n    key: \"addToTracker\",\n    value: function addToTracker(event) {\n      if (this.trackedPointers.has(event.pointerId)) {\n        return;\n      }\n      this.lastMovedPointerId = event.pointerId;\n      var newElement = {\n        lastX: event.x,\n        lastY: event.y,\n        timeStamp: event.time,\n        velocityX: 0,\n        velocityY: 0\n      };\n      this.trackedPointers.set(event.pointerId, newElement);\n      this.mapTouchEventId(event.pointerId);\n      this.cachedAverages = {\n        x: this.getLastAvgX(),\n        y: this.getLastAvgY()\n      };\n    }\n  }, {\n    key: \"removeFromTracker\",\n    value: function removeFromTracker(pointerId) {\n      this.trackedPointers[\"delete\"](pointerId);\n      this.removeMappedTouchId(pointerId);\n    }\n  }, {\n    key: \"track\",\n    value: function track(event) {\n      var element = this.trackedPointers.get(event.pointerId);\n      if (!element) {\n        return;\n      }\n      this.lastMovedPointerId = event.pointerId;\n      var dx = event.x - element.lastX;\n      var dy = event.y - element.lastY;\n      var dt = event.time - element.timeStamp;\n      element.velocityX = dx / dt * 1000 * VELOCITY_FACTOR;\n      element.velocityY = dy / dt * 1000 * VELOCITY_FACTOR;\n      element.lastX = event.x;\n      element.lastY = event.y;\n      this.trackedPointers.set(event.pointerId, element);\n      var avgX = this.getLastAvgX();\n      var avgY = this.getLastAvgY();\n      this.cachedAverages = {\n        x: avgX,\n        y: avgY\n      };\n    }\n  }, {\n    key: \"mapTouchEventId\",\n    value: function mapTouchEventId(id) {\n      var _iterator = _createForOfIteratorHelper(this.touchEventsIds),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            mappedId = _step$value[0],\n            touchId = _step$value[1];\n          if (isNaN(touchId)) {\n            this.touchEventsIds.set(mappedId, id);\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"removeMappedTouchId\",\n    value: function removeMappedTouchId(id) {\n      var mappedId = this.getMappedTouchEventId(id);\n      if (!isNaN(mappedId)) {\n        this.touchEventsIds.set(mappedId, NaN);\n      }\n    }\n  }, {\n    key: \"getMappedTouchEventId\",\n    value: function getMappedTouchEventId(touchEventId) {\n      var _iterator2 = _createForOfIteratorHelper(this.touchEventsIds.entries()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n            key = _step2$value[0],\n            value = _step2$value[1];\n          if (value === touchEventId) {\n            return key;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return NaN;\n    }\n  }, {\n    key: \"getVelocityX\",\n    value: function getVelocityX(pointerId) {\n      var _this$trackedPointers;\n      return (_this$trackedPointers = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers === void 0 ? void 0 : _this$trackedPointers.velocityX;\n    }\n  }, {\n    key: \"getVelocityY\",\n    value: function getVelocityY(pointerId) {\n      var _this$trackedPointers2;\n      return (_this$trackedPointers2 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers2 === void 0 ? void 0 : _this$trackedPointers2.velocityY;\n    }\n  }, {\n    key: \"getLastX\",\n    value: function getLastX(pointerId) {\n      if (pointerId !== undefined) {\n        var _this$trackedPointers3;\n        return (_this$trackedPointers3 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers3 === void 0 ? void 0 : _this$trackedPointers3.lastX;\n      } else {\n        var _this$trackedPointers4;\n        return (_this$trackedPointers4 = this.trackedPointers.get(this.lastMovedPointerId)) === null || _this$trackedPointers4 === void 0 ? void 0 : _this$trackedPointers4.lastX;\n      }\n    }\n  }, {\n    key: \"getLastY\",\n    value: function getLastY(pointerId) {\n      if (pointerId !== undefined) {\n        var _this$trackedPointers5;\n        return (_this$trackedPointers5 = this.trackedPointers.get(pointerId)) === null || _this$trackedPointers5 === void 0 ? void 0 : _this$trackedPointers5.lastY;\n      } else {\n        var _this$trackedPointers6;\n        return (_this$trackedPointers6 = this.trackedPointers.get(this.lastMovedPointerId)) === null || _this$trackedPointers6 === void 0 ? void 0 : _this$trackedPointers6.lastY;\n      }\n    }\n  }, {\n    key: \"getLastAvgX\",\n    value: function getLastAvgX() {\n      var avgX = this.getSumX() / this.trackedPointers.size;\n      return isNaN(avgX) ? this.cachedAverages.x : avgX;\n    }\n  }, {\n    key: \"getLastAvgY\",\n    value: function getLastAvgY() {\n      var avgY = this.getSumY() / this.trackedPointers.size;\n      return isNaN(avgY) ? this.cachedAverages.y : avgY;\n    }\n  }, {\n    key: \"getSumX\",\n    value: function getSumX(ignoredPointer) {\n      var sumX = 0;\n      this.trackedPointers.forEach(function (value, key) {\n        if (key !== ignoredPointer) {\n          sumX += value.lastX;\n        }\n      });\n      return sumX;\n    }\n  }, {\n    key: \"getSumY\",\n    value: function getSumY(ignoredPointer) {\n      var sumY = 0;\n      this.trackedPointers.forEach(function (value, key) {\n        if (key !== ignoredPointer) {\n          sumY += value.lastY;\n        }\n      });\n      return sumY;\n    }\n  }, {\n    key: \"getTrackedPointersCount\",\n    value: function getTrackedPointersCount() {\n      return this.trackedPointers.size;\n    }\n  }, {\n    key: \"getTrackedPointersID\",\n    value: function getTrackedPointersID() {\n      var keys = [];\n      this.trackedPointers.forEach(function (_value, key) {\n        keys.push(key);\n      });\n      return keys;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.trackedPointers;\n    }\n  }, {\n    key: \"resetTracker\",\n    value: function resetTracker() {\n      this.trackedPointers.clear();\n      this.lastMovedPointerId = NaN;\n      for (var i = 0; i < MAX_POINTERS; ++i) {\n        this.touchEventsIds.set(i, NaN);\n      }\n    }\n  }], [{\n    key: \"shareCommonPointers\",\n    value: function shareCommonPointers(stPointers, ndPointers) {\n      return stPointers.some(function (pointerId) {\n        return ndPointers.includes(pointerId);\n      });\n    }\n  }]);\n}();\nexport { PointerTracker as default };","map":{"version":3,"names":["VELOCITY_FACTOR","MAX_POINTERS","PointerTracker","_classCallCheck","_defineProperty","Map","x","y","lastMovedPointerId","NaN","i","touchEventsIds","set","_createClass","key","value","addToTracker","event","trackedPointers","has","pointerId","newElement","lastX","lastY","timeStamp","time","velocityX","velocityY","mapTouchEventId","cachedAverages","getLastAvgX","getLastAvgY","removeFromTracker","removeMappedTouchId","track","element","get","dx","dy","dt","avgX","avgY","id","_iterator","_createForOfIteratorHelper","_step","s","n","done","_step$value","_slicedToArray","mappedId","touchId","isNaN","err","e","f","getMappedTouchEventId","touchEventId","_iterator2","entries","_step2","_step2$value","getVelocityX","_this$trackedPointers","getVelocityY","_this$trackedPointers2","getLastX","undefined","_this$trackedPointers3","_this$trackedPointers4","getLastY","_this$trackedPointers5","_this$trackedPointers6","getSumX","size","getSumY","ignoredPointer","sumX","forEach","sumY","getTrackedPointersCount","getTrackedPointersID","keys","_value","push","getData","resetTracker","clear","shareCommonPointers","stPointers","ndPointers","some","includes","default"],"sources":["C:\\Users\\adenk\\OneDrive - Toi Ohomai Institute of Technology\\Desktop\\test\\node_modules\\react-native-gesture-handler\\lib\\module\\web\\tools\\PointerTracker.ts"],"sourcesContent":["import { AdaptedEvent } from '../interfaces';\n\nexport interface TrackerElement {\n  lastX: number;\n  lastY: number;\n\n  timeStamp: number;\n\n  velocityX: number;\n  velocityY: number;\n}\n\n// Used to scale velocity so that it is similar to velocity in Android/iOS\nconst VELOCITY_FACTOR = 0.2;\nconst MAX_POINTERS = 20;\n\nexport default class PointerTracker {\n  private trackedPointers: Map<number, TrackerElement> = new Map<\n    number,\n    TrackerElement\n  >();\n\n  private touchEventsIds: Map<number, number> = new Map<number, number>();\n\n  private lastMovedPointerId: number;\n\n  private cachedAverages: { x: number; y: number } = { x: 0, y: 0 };\n\n  public constructor() {\n    this.lastMovedPointerId = NaN;\n\n    for (let i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n\n  public addToTracker(event: AdaptedEvent): void {\n    if (this.trackedPointers.has(event.pointerId)) {\n      return;\n    }\n\n    this.lastMovedPointerId = event.pointerId;\n\n    const newElement: TrackerElement = {\n      lastX: event.x,\n      lastY: event.y,\n      timeStamp: event.time,\n      velocityX: 0,\n      velocityY: 0,\n    };\n\n    this.trackedPointers.set(event.pointerId, newElement);\n    this.mapTouchEventId(event.pointerId);\n\n    this.cachedAverages = {\n      x: this.getLastAvgX(),\n      y: this.getLastAvgY(),\n    };\n  }\n\n  public removeFromTracker(pointerId: number): void {\n    this.trackedPointers.delete(pointerId);\n    this.removeMappedTouchId(pointerId);\n  }\n\n  public track(event: AdaptedEvent): void {\n    const element: TrackerElement = this.trackedPointers.get(\n      event.pointerId\n    ) as TrackerElement;\n\n    if (!element) {\n      return;\n    }\n\n    this.lastMovedPointerId = event.pointerId;\n\n    const dx = event.x - element.lastX;\n    const dy = event.y - element.lastY;\n    const dt = event.time - element.timeStamp;\n\n    element.velocityX = (dx / dt) * 1000 * VELOCITY_FACTOR;\n    element.velocityY = (dy / dt) * 1000 * VELOCITY_FACTOR;\n\n    element.lastX = event.x;\n    element.lastY = event.y;\n\n    this.trackedPointers.set(event.pointerId, element);\n\n    const avgX: number = this.getLastAvgX();\n    const avgY: number = this.getLastAvgY();\n\n    this.cachedAverages = {\n      x: avgX,\n      y: avgY,\n    };\n  }\n\n  //Mapping TouchEvents ID\n  private mapTouchEventId(id: number): void {\n    for (const [mappedId, touchId] of this.touchEventsIds) {\n      if (isNaN(touchId)) {\n        this.touchEventsIds.set(mappedId, id);\n        break;\n      }\n    }\n  }\n\n  private removeMappedTouchId(id: number): void {\n    const mappedId: number = this.getMappedTouchEventId(id);\n    if (!isNaN(mappedId)) {\n      this.touchEventsIds.set(mappedId, NaN);\n    }\n  }\n\n  public getMappedTouchEventId(touchEventId: number): number {\n    for (const [key, value] of this.touchEventsIds.entries()) {\n      if (value === touchEventId) {\n        return key;\n      }\n    }\n\n    return NaN;\n  }\n\n  public getVelocityX(pointerId: number): number {\n    return this.trackedPointers.get(pointerId)?.velocityX as number;\n  }\n  public getVelocityY(pointerId: number): number {\n    return this.trackedPointers.get(pointerId)?.velocityY as number;\n  }\n\n  /**\n   * Returns X coordinate of last moved pointer\n   */\n  public getLastX(): number;\n\n  /**\n   *\n   * @param pointerId\n   * Returns X coordinate of given pointer\n   */\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  public getLastX(pointerId: number): number;\n\n  public getLastX(pointerId?: number): number {\n    if (pointerId !== undefined) {\n      return this.trackedPointers.get(pointerId)?.lastX as number;\n    } else {\n      return this.trackedPointers.get(this.lastMovedPointerId)?.lastX as number;\n    }\n  }\n\n  /**\n   * Returns Y coordinate of last moved pointer\n   */\n  public getLastY(): number;\n\n  /**\n   *\n   * @param pointerId\n   * Returns Y coordinate of given pointer\n   */\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  public getLastY(pointerId: number): number;\n\n  public getLastY(pointerId?: number): number {\n    if (pointerId !== undefined) {\n      return this.trackedPointers.get(pointerId)?.lastY as number;\n    } else {\n      return this.trackedPointers.get(this.lastMovedPointerId)?.lastY as number;\n    }\n  }\n\n  // Some handlers use these methods to send average values in native event.\n  // This may happen when pointers have already been removed from tracker (i.e. pointerup event).\n  // In situation when NaN would be sent as a response, we return cached value.\n  // That prevents handlers from crashing\n  public getLastAvgX(): number {\n    const avgX: number = this.getSumX() / this.trackedPointers.size;\n    return isNaN(avgX) ? this.cachedAverages.x : avgX;\n  }\n  public getLastAvgY(): number {\n    const avgY: number = this.getSumY() / this.trackedPointers.size;\n    return isNaN(avgY) ? this.cachedAverages.y : avgY;\n  }\n  public getSumX(ignoredPointer?: number): number {\n    let sumX = 0;\n\n    this.trackedPointers.forEach((value, key) => {\n      if (key !== ignoredPointer) {\n        sumX += value.lastX;\n      }\n    });\n\n    return sumX;\n  }\n  public getSumY(ignoredPointer?: number): number {\n    let sumY = 0;\n\n    this.trackedPointers.forEach((value, key) => {\n      if (key !== ignoredPointer) {\n        sumY += value.lastY;\n      }\n    });\n\n    return sumY;\n  }\n  public getTrackedPointersCount(): number {\n    return this.trackedPointers.size;\n  }\n  public getTrackedPointersID(): number[] {\n    const keys: number[] = [];\n\n    this.trackedPointers.forEach((_value, key) => {\n      keys.push(key);\n    });\n\n    return keys;\n  }\n\n  public getData(): Map<number, TrackerElement> {\n    return this.trackedPointers;\n  }\n\n  public resetTracker(): void {\n    this.trackedPointers.clear();\n    this.lastMovedPointerId = NaN;\n\n    for (let i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n\n  public static shareCommonPointers(\n    stPointers: number[],\n    ndPointers: number[]\n  ): boolean {\n    return stPointers.some((pointerId) => ndPointers.includes(pointerId));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}