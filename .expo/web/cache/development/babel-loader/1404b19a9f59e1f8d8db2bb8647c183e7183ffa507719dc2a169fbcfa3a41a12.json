{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldSet(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nimport { has } from \"./utils.js\";\nimport { WorkletEventHandler } from \"../WorkletEventHandler.js\";\nimport { findNodeHandle } from \"../platformFunctions/findNodeHandle\";\nvar _managedComponent = new WeakMap();\nvar _componentOptions = new WeakMap();\nvar _eventViewTag = new WeakMap();\nexport var NativeEventsManager = function () {\n  function NativeEventsManager(component, options) {\n    _classCallCheck(this, NativeEventsManager);\n    _classPrivateFieldInitSpec(this, _managedComponent, void 0);\n    _classPrivateFieldInitSpec(this, _componentOptions, void 0);\n    _classPrivateFieldInitSpec(this, _eventViewTag, -1);\n    _classPrivateFieldSet(_managedComponent, this, component);\n    _classPrivateFieldSet(_componentOptions, this, options);\n    _classPrivateFieldSet(_eventViewTag, this, this.getEventViewTag());\n  }\n  return _createClass(NativeEventsManager, [{\n    key: \"attachEvents\",\n    value: function attachEvents() {\n      var _this = this;\n      executeForEachEventHandler(_classPrivateFieldGet(_managedComponent, this).props, function (key, handler) {\n        handler.registerForEvents(_classPrivateFieldGet(_eventViewTag, _this), key);\n      });\n    }\n  }, {\n    key: \"detachEvents\",\n    value: function detachEvents() {\n      var _this2 = this;\n      executeForEachEventHandler(_classPrivateFieldGet(_managedComponent, this).props, function (_key, handler) {\n        handler.unregisterFromEvents(_classPrivateFieldGet(_eventViewTag, _this2));\n      });\n    }\n  }, {\n    key: \"updateEvents\",\n    value: function updateEvents(prevProps) {\n      var _this3 = this;\n      var computedEventTag = this.getEventViewTag(true);\n      if (_classPrivateFieldGet(_eventViewTag, this) !== computedEventTag) {\n        executeForEachEventHandler(prevProps, function (_key, handler) {\n          handler.unregisterFromEvents(_classPrivateFieldGet(_eventViewTag, _this3));\n        });\n        _classPrivateFieldSet(_eventViewTag, this, computedEventTag);\n        this.attachEvents();\n        return;\n      }\n      executeForEachEventHandler(prevProps, function (key, prevHandler) {\n        var newProp = _classPrivateFieldGet(_managedComponent, _this3).props[key];\n        if (!newProp) {\n          prevHandler.unregisterFromEvents(_classPrivateFieldGet(_eventViewTag, _this3));\n        } else if (isWorkletEventHandler(newProp) && newProp.workletEventHandler !== prevHandler) {\n          prevHandler.unregisterFromEvents(_classPrivateFieldGet(_eventViewTag, _this3));\n          newProp.workletEventHandler.registerForEvents(_classPrivateFieldGet(_eventViewTag, _this3));\n        }\n      });\n      executeForEachEventHandler(_classPrivateFieldGet(_managedComponent, this).props, function (key, handler) {\n        if (!prevProps[key]) {\n          handler.registerForEvents(_classPrivateFieldGet(_eventViewTag, _this3));\n        }\n      });\n    }\n  }, {\n    key: \"getEventViewTag\",\n    value: function getEventViewTag() {\n      var _classPrivateFieldGet2, _findNodeHandle3;\n      var componentUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var componentAnimatedRef = _classPrivateFieldGet(_managedComponent, this)._componentRef;\n      if (componentAnimatedRef.getScrollableNode) {\n        var _findNodeHandle;\n        var scrollableNode = componentAnimatedRef.getScrollableNode();\n        if (typeof scrollableNode === 'number') {\n          return scrollableNode;\n        }\n        return (_findNodeHandle = findNodeHandle(scrollableNode)) !== null && _findNodeHandle !== void 0 ? _findNodeHandle : -1;\n      }\n      if ((_classPrivateFieldGet2 = _classPrivateFieldGet(_componentOptions, this)) !== null && _classPrivateFieldGet2 !== void 0 && _classPrivateFieldGet2.setNativeProps) {\n        var _findNodeHandle2;\n        return (_findNodeHandle2 = findNodeHandle(_classPrivateFieldGet(_managedComponent, this))) !== null && _findNodeHandle2 !== void 0 ? _findNodeHandle2 : -1;\n      }\n      if (!componentUpdate) {\n        return _classPrivateFieldGet(_managedComponent, this).getComponentViewTag();\n      }\n      if (componentAnimatedRef.__nativeTag || componentAnimatedRef._nativeTag) {\n        var _ref, _componentAnimatedRef;\n        return (_ref = (_componentAnimatedRef = componentAnimatedRef.__nativeTag) !== null && _componentAnimatedRef !== void 0 ? _componentAnimatedRef : componentAnimatedRef._nativeTag) !== null && _ref !== void 0 ? _ref : -1;\n      }\n      return (_findNodeHandle3 = findNodeHandle(componentAnimatedRef)) !== null && _findNodeHandle3 !== void 0 ? _findNodeHandle3 : -1;\n    }\n  }]);\n}();\nfunction isWorkletEventHandler(prop) {\n  return has('workletEventHandler', prop) && prop.workletEventHandler instanceof WorkletEventHandler;\n}\nfunction executeForEachEventHandler(props, callback) {\n  for (var key in props) {\n    var prop = props[key];\n    if (isWorkletEventHandler(prop)) {\n      callback(key, prop.workletEventHandler);\n    }\n  }\n}","map":{"version":3,"names":["_classCallCheck","_createClass","_classPrivateFieldInitSpec","e","t","a","_checkPrivateRedeclaration","set","has","TypeError","_classPrivateFieldGet","s","get","_assertClassBrand","_classPrivateFieldSet","r","n","arguments","length","WorkletEventHandler","findNodeHandle","_managedComponent","WeakMap","_componentOptions","_eventViewTag","NativeEventsManager","component","options","getEventViewTag","key","value","attachEvents","_this","executeForEachEventHandler","props","handler","registerForEvents","detachEvents","_this2","_key","unregisterFromEvents","updateEvents","prevProps","_this3","computedEventTag","prevHandler","newProp","isWorkletEventHandler","workletEventHandler","_classPrivateFieldGet2","_findNodeHandle3","componentUpdate","undefined","componentAnimatedRef","_componentRef","getScrollableNode","_findNodeHandle","scrollableNode","setNativeProps","_findNodeHandle2","getComponentViewTag","__nativeTag","_nativeTag","_ref","_componentAnimatedRef","prop","callback"],"sources":["C:\\Users\\adenk\\OneDrive - Toi Ohomai Institute of Technology\\Desktop\\test\\node_modules\\react-native-reanimated\\src\\createAnimatedComponent\\NativeEventsManager.ts"],"sourcesContent":["'use strict';\nimport type {\n  INativeEventsManager,\n  IAnimatedComponentInternal,\n  AnimatedComponentProps,\n  InitialComponentProps,\n  AnimatedComponentRef,\n} from './commonTypes';\nimport { has } from './utils';\nimport { WorkletEventHandler } from '../WorkletEventHandler';\nimport { findNodeHandle } from '../platformFunctions/findNodeHandle';\n\nexport class NativeEventsManager implements INativeEventsManager {\n  readonly #managedComponent: ManagedAnimatedComponent;\n  readonly #componentOptions?: ComponentOptions;\n  #eventViewTag = -1;\n\n  constructor(component: ManagedAnimatedComponent, options?: ComponentOptions) {\n    this.#managedComponent = component;\n    this.#componentOptions = options;\n    this.#eventViewTag = this.getEventViewTag();\n  }\n\n  public attachEvents() {\n    executeForEachEventHandler(this.#managedComponent.props, (key, handler) => {\n      handler.registerForEvents(this.#eventViewTag, key);\n    });\n  }\n\n  public detachEvents() {\n    executeForEachEventHandler(\n      this.#managedComponent.props,\n      (_key, handler) => {\n        handler.unregisterFromEvents(this.#eventViewTag);\n      }\n    );\n  }\n\n  public updateEvents(\n    prevProps: AnimatedComponentProps<InitialComponentProps>\n  ) {\n    const computedEventTag = this.getEventViewTag(true);\n    // If the event view tag changes, we need to completely re-mount all events\n    if (this.#eventViewTag !== computedEventTag) {\n      // Remove all bindings from previous props that ran on the old viewTag\n      executeForEachEventHandler(prevProps, (_key, handler) => {\n        handler.unregisterFromEvents(this.#eventViewTag);\n      });\n      // We don't need to unregister from current (new) props, because their events weren't registered yet\n      // Replace the view tag\n      this.#eventViewTag = computedEventTag;\n      // Attach the events with a new viewTag\n      this.attachEvents();\n      return;\n    }\n\n    executeForEachEventHandler(prevProps, (key, prevHandler) => {\n      const newProp = this.#managedComponent.props[key];\n      if (!newProp) {\n        // Prop got deleted\n        prevHandler.unregisterFromEvents(this.#eventViewTag);\n      } else if (\n        isWorkletEventHandler(newProp) &&\n        newProp.workletEventHandler !== prevHandler\n      ) {\n        // Prop got changed\n        prevHandler.unregisterFromEvents(this.#eventViewTag);\n        newProp.workletEventHandler.registerForEvents(this.#eventViewTag);\n      }\n    });\n\n    executeForEachEventHandler(this.#managedComponent.props, (key, handler) => {\n      if (!prevProps[key]) {\n        // Prop got added\n        handler.registerForEvents(this.#eventViewTag);\n      }\n    });\n  }\n\n  private getEventViewTag(componentUpdate: boolean = false) {\n    // Get the tag for registering events - since the event emitting view can be nested inside the main component\n    const componentAnimatedRef = this.#managedComponent\n      ._componentRef as AnimatedComponentRef & {\n      // Fabric\n      __nativeTag?: number;\n      // Paper\n      _nativeTag?: number;\n    };\n    if (componentAnimatedRef.getScrollableNode) {\n      /*\n        In most cases, getScrollableNode() returns a view tag, and findNodeHandle is not required. \n        However, to cover more exotic list cases, we will continue to use findNodeHandle \n        for consistency. For numerical values, findNodeHandle should return the value immediately, \n        as documented here: https://github.com/facebook/react/blob/91061073d57783c061889ac6720ef1ab7f0c2149/packages/react-native-renderer/src/ReactNativePublicCompat.js#L113\n      */\n      const scrollableNode = componentAnimatedRef.getScrollableNode();\n      if (typeof scrollableNode === 'number') {\n        return scrollableNode;\n      }\n      return findNodeHandle(scrollableNode) ?? -1;\n    }\n    if (this.#componentOptions?.setNativeProps) {\n      // This case ensures backward compatibility with components that\n      // have their own setNativeProps method passed as an option.\n      return findNodeHandle(this.#managedComponent) ?? -1;\n    }\n    if (!componentUpdate) {\n      // On the first render of a component, we may already receive a resolved view tag.\n      return this.#managedComponent.getComponentViewTag();\n    }\n    if (componentAnimatedRef.__nativeTag || componentAnimatedRef._nativeTag) {\n      /*\n        Fast path for native refs,\n        _nativeTag is used by Paper components,\n        __nativeTag is used by Fabric components.\n      */\n      return (\n        componentAnimatedRef.__nativeTag ??\n        componentAnimatedRef._nativeTag ??\n        -1\n      );\n    }\n    /*\n      When a component is updated, a child could potentially change and have a different \n      view tag. This can occur with a GestureDetector component.\n    */\n    return findNodeHandle(componentAnimatedRef) ?? -1;\n  }\n}\n\nfunction isWorkletEventHandler(\n  prop: unknown\n): prop is WorkletEventHandlerHolder {\n  return (\n    has('workletEventHandler', prop) &&\n    prop.workletEventHandler instanceof WorkletEventHandler\n  );\n}\n\nfunction executeForEachEventHandler(\n  props: AnimatedComponentProps<InitialComponentProps>,\n  callback: (\n    key: string,\n    handler: InstanceType<typeof WorkletEventHandler>\n  ) => void\n) {\n  for (const key in props) {\n    const prop = props[key];\n    if (isWorkletEventHandler(prop)) {\n      callback(key, prop.workletEventHandler);\n    }\n  }\n}\n\ntype ManagedAnimatedComponent = React.Component<\n  AnimatedComponentProps<InitialComponentProps>\n> &\n  IAnimatedComponentInternal;\n\ntype ComponentOptions = {\n  setNativeProps: (\n    ref: AnimatedComponentRef,\n    props: InitialComponentProps\n  ) => void;\n};\n\ntype WorkletEventHandlerHolder = {\n  workletEventHandler: InstanceType<typeof WorkletEventHandler>;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}